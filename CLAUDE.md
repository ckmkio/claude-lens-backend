# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Node.js Express backend service built with Express generator. The project serves as a backend for managing Claude Code conversation scheduling and token usage synchronization from client machines.

## Development Commands

### Start the server
```bash
npm start
```
This runs the server using `node ./bin/www` on port 3000 (configurable via PORT environment variable).

### Install dependencies
```bash
npm install
```

## Architecture

### Core Structure
- **app.js**: Main Express application setup with middleware configuration
- **bin/www**: Server startup script that creates HTTP server and handles port configuration
- **routes/**: Contains route definitions
  - `index.js`: Root route handler
  - `users.js`: User-related routes
- **public/**: Static assets (CSS, client-side JavaScript, images)

### Key Dependencies
- **Express 4.16.1**: Web framework
- **Morgan**: HTTP request logging middleware  
- **Cookie-parser**: Cookie parsing middleware
- **Debug**: Debugging utility with namespace support

### Application Flow
The application follows standard Express generator structure:
1. Server starts via `bin/www` which imports the Express app
2. `app.js` configures middleware stack and mounts route handlers
3. Routes are modularized in separate files under `routes/`
4. Static files served from `public/` directory

### Port Configuration
Server runs on port 3000 by default, configurable via `PORT` environment variable. The startup script includes proper error handling for port conflicts and permission issues.

### Current Implementation Status
The project appears to be in early development stage with basic Express scaffolding in place. Routes currently return placeholder responses and will need implementation for the Claude Code conversation scheduling and token synchronization features.

---

# Claude Usage Sync Feature - Requirements & Design

## Overview
Real-time synchronization of Claude Code usage data from multiple client machines AND the backend server itself to calculate unified 5-hour usage windows and token consumption.

## Core Concept

### Claude 5 Hours Limitation
- Claude uses rolling 5-hour windows to reset usage limits
- Need to track all client usage to calculate unified windows
- Earliest start time determines the sync window start point

### Usage Data Sources
1. **External Clients**: Use `ccusage blocks --json` via WebSocket
2. **Backend Server**: Execute `ccusage blocks --json` via scheduled cron jobs

Both sources generate the same data structure:
```json
{
  "blocks": [{
    "id": "2025-08-28T02:00:00.000Z",
    "startTime": "2025-08-28T02:00:00.000Z", 
    "endTime": "2025-08-28T07:00:00.000Z",
    "actualEndTime": "2025-08-28T03:54:22.422Z",
    "isActive": true,
    "totalTokens": 1436169,
    "costUSD": 0.85003995
    // ... more fields
  }]
}
```

## Architecture Design

### Dual-Role Backend Server

The backend server operates in **dual roles**:

1. **Server Role**: 
   - Receives WebSocket connections from external clients
   - Processes and stores usage data
   - Calculates unified sync windows
   - Responds with sync status

2. **Client Role**:
   - Executes scheduled cron jobs that run Claude commands
   - Monitors its own usage via `ccusage blocks --json`
   - **Direct Database Insert**: Bypasses WebSocket, writes directly to database
   - Uses same change detection logic (SHA256 hash comparison)

### Time Window Synchronization Logic

**Example Scenario**:
- Backend Server: starts at 10am, 5-hour window = 10am-3pm
- External Client A: starts at 11am, 5-hour window = 11am-4pm  
- External Client B: starts at 12pm, 5-hour window = 12pm-5pm
- **Sync Window**: 10am-3pm (based on earliest start time from backend)
- All clients' data before 3pm counts toward current window, data after 3pm waits for next window

### Database Schema

```sql
CREATE TABLE usage_blocks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  block_id VARCHAR NOT NULL,        -- ccusage id (startTime)
  client_id UUID NOT NULL,          -- client UUID (generated by backend, including backend itself)
  
  -- ccusage original time data
  start_time TIMESTAMP NOT NULL,
  end_time TIMESTAMP NOT NULL, 
  actual_end_time TIMESTAMP,
  is_active BOOLEAN NOT NULL,
  
  -- key timestamps
  ccusage_fetched_at TIMESTAMP NOT NULL, -- when client executed ccusage
  server_received_at TIMESTAMP DEFAULT NOW(),
  
  -- usage data
  total_tokens BIGINT NOT NULL,
  cost_usd DECIMAL,
  token_counts JSONB,               -- complete tokenCounts object
  raw_data JSONB,                   -- complete ccusage raw data
  
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(block_id, client_id)
);
```

### Communication Protocol

#### WebSocket Messages

**Client Registration**:
```javascript
// POST /api/register-client
Response: { "clientId": "uuid", "registered": true }
```

**Usage Data Update**:
```javascript
// Client → Server
{
  "type": "usage_update",
  "clientId": "uuid", 
  "ccusageFetchedAt": "2025-08-28T10:30:00Z",
  "signature": "sha256_hash_of_ccusage_json",
  "blocks": [/* ccusage blocks data */]
}

// Server → Client
{
  "type": "sync_response",
  "success": true,
  "syncWindow": {
    "start": "2025-08-28T10:00:00Z",
    "end": "2025-08-28T15:00:00Z", 
    "totalTokens": 1500,
    "clientCount": 2,
    "isActive": true
  }
}
```

**Error Handling**:
```javascript
{
  "type": "error",
  "code": 4001,  // 4000-4999 custom error codes
  "message": "Client not registered",
  "timestamp": "2025-08-28T10:30:00Z"
}
```

#### Error Codes
- `4000`: Invalid data format
- `4001`: Client not registered
- `4002`: Authentication failed
- `4003`: Data processing failed

### Client-Side Logic

#### Change Detection
```javascript
// Use SHA256 hash of entire JSON to detect changes
function getJsonSignature(ccusageOutput) {
  const normalized = JSON.stringify(ccusageOutput, Object.keys(ccusageOutput).sort());
  return crypto.createHash('sha256').update(normalized).digest('hex');
}
```

#### Sync Strategy
1. Periodically execute `ccusage blocks --json` (configurable interval)
2. Calculate JSON signature 
3. Compare with previous signature
4. Send to backend via WebSocket when changed
5. Receive backend response with sync window status

#### Connection Management
- **Reconnect Strategy**: Exponential backoff (1s, 2s, 4s, 8s, max 30s)
- **Data Buffering**: Cache unsent data when disconnected
- **Heartbeat**: Regular ping/pong to maintain connection
- **Secure Connection**: Use WSS encryption

### Sync Window Calculation

```sql
-- Calculate current sync window
WITH sync_window AS (
  SELECT 
    MIN(start_time) as window_start,
    MIN(start_time) + INTERVAL '5 hours' as window_end
  FROM usage_blocks 
  WHERE is_active = true
    AND ccusage_fetched_at > NOW() - INTERVAL '10 minutes'
)
SELECT 
  window_start,
  window_end,
  SUM(total_tokens) as total_tokens,
  SUM(cost_usd) as total_cost,
  COUNT(DISTINCT client_id) as client_count
FROM usage_blocks, sync_window
WHERE ccusage_fetched_at <= window_end
  AND start_time >= window_start;
```

## Implementation Plan

### Phase 1: Core Infrastructure
1. Setup PostgreSQL database and schema
2. Implement WebSocket server infrastructure
3. Client registration API and UUID management
4. **Backend self-registration**: Generate UUID for backend server itself

### Phase 2: Data Processing
1. Receive and store ccusage data from WebSocket clients
2. **Backend cron job**: Scheduled ccusage monitoring with direct DB insert
3. Time window calculation logic (unified for all sources)
4. Sync status calculation and response

### Phase 3: Client Integration  
1. External client WebSocket connection and reconnection logic
2. Data change detection and sync (both external and backend)
3. Error handling and buffering mechanism
4. **Backend usage monitoring**: Cron-based ccusage execution

### Phase 4: Advanced Features
1. REST API query interface
2. Client management and monitoring (including backend as a client)
3. Historical data reporting features
4. **Cron job management**: Configure backend usage monitoring frequency

## Edge Cases Handled

1. **Client Crashes**: Automatically handled through time window timeouts
2. **Network Disconnection**: Reconnection and data buffering mechanisms
3. **Time Desynchronization**: Use `ccusage_fetched_at` to determine data window ownership
4. **Late Arrival of Early Data**: Dynamically adjust time window based on earliest start time
5. **Duplicate Data**: Use `(block_id, client_id)` unique constraint
6. **State Changes**: Handle active/inactive block status updates

## Technical Decisions

- **Single Table Design**: Use `usage_blocks` table to calculate sync windows in real-time
- **Complete JSON Comparison**: Use SHA256 hash to detect all changes
- **Backend UUID Management**: Support future client management features
- **WebSocket + REST**: WebSocket for real-time sync, REST API for queries
- **PostgreSQL**: Support for JSONB and complex time queries

---

# Testing & Development Tools

## Multi-Client Test Data Generator

### Overview
Since testing multiple client environments is complex, we need a test data generator that simulates various client scenarios in real-time.

### Test Scenarios to Simulate

1. **Normal Multi-Client Usage**:
   - 2-3 clients starting at different times
   - Overlapping time windows
   - Different token consumption rates

2. **Edge Cases**:
   - Late arrival of early data (client A starts first but reports later)
   - Client disconnection and reconnection
   - Active blocks becoming inactive
   - Time window transitions

3. **Stress Testing**:
   - Multiple clients with rapid updates
   - Large token consumption numbers
   - Network latency simulation

### Test Data Generator Design

#### Mock Client Structure
```javascript
class MockClient {
  constructor(clientId, startOffset = 0, tokenBurnRate = 100) {
    this.clientId = clientId;
    this.startTime = new Date(Date.now() + startOffset * 1000);
    this.currentTokens = 0;
    this.tokenBurnRate = tokenBurnRate; // tokens per minute
    this.isActive = true;
    this.blockId = this.startTime.toISOString();
  }
  
  generateUsageBlock() {
    // Generate realistic ccusage block data
  }
}
```

#### Test Scenarios
```javascript
const testScenarios = {
  // Scenario 1: Normal overlap
  normalOverlap: {
    clients: [
      { id: 'client-A', startOffset: 0, burnRate: 150 },      // starts now
      { id: 'client-B', startOffset: 7200, burnRate: 200 },   // starts 2h later
      { id: 'client-C', startOffset: 3600, burnRate: 100 }    // starts 1h later
    ],
    description: "Three clients with staggered start times"
  },
  
  // Scenario 2: Late reporting
  lateReporting: {
    clients: [
      { id: 'early-client', startOffset: 0, reportDelay: 1800 },  // starts first, reports 30min late
      { id: 'later-client', startOffset: 1800, reportDelay: 60 }  // starts later, reports quickly
    ],
    description: "Early client reports data later than later client"
  },
  
  // Scenario 3: Window transition
  windowTransition: {
    clients: [
      { id: 'long-client', startOffset: 0, duration: 6 * 3600 }  // 6-hour usage spanning two windows
    ],
    description: "Single client usage spanning multiple 5-hour windows"
  }
};
```

### Implementation Files

#### 1. Test Data Generator (`test/data-generator.js`)
- Generate realistic ccusage block data
- Simulate different client behaviors
- Control timing and token burn rates

#### 2. Mock Client Simulator (`test/mock-client.js`)
- WebSocket client that mimics real client behavior
- Configurable scenarios and edge cases
- Real-time data posting with realistic delays

#### 3. Test Scenarios Runner (`test/scenarios.js`)
- Orchestrate multiple mock clients
- Run predefined test scenarios
- Capture and validate sync window calculations

#### 4. Performance Testing (`test/stress-test.js`)
- High-frequency updates
- Multiple concurrent connections
- Memory and performance monitoring

### Sample Test Data Structure

```javascript
// Generated test block data
{
  "blocks": [{
    "id": "2025-08-28T10:00:00.000Z",
    "startTime": "2025-08-28T10:00:00.000Z",
    "endTime": "2025-08-28T15:00:00.000Z",
    "actualEndTime": null,  // or timestamp if inactive
    "isActive": true,
    "isGap": false,
    "entries": 45,
    "tokenCounts": {
      "inputTokens": Math.floor(Math.random() * 1000),
      "outputTokens": Math.floor(Math.random() * 5000),
      "cacheCreationInputTokens": Math.floor(Math.random() * 10000),
      "cacheReadInputTokens": Math.floor(Math.random() * 50000)
    },
    "totalTokens": /* calculated sum */,
    "costUSD": /* calculated cost */,
    "models": ["claude-sonnet-4-20250514"],
    "burnRate": {
      "tokensPerMinute": /* calculated */,
      "tokensPerMinuteForIndicator": /* calculated */,
      "costPerHour": /* calculated */
    },
    "projection": {
      "totalTokens": /* projected */,
      "totalCost": /* projected */,
      "remainingMinutes": /* calculated */
    }
  }]
}
```

### Usage Commands

```bash
# Run basic multi-client test
npm run test:multi-client

# Run specific scenario
npm run test:scenario -- --name=normalOverlap

# Run stress test
npm run test:stress -- --clients=10 --duration=300

# Run edge case simulation
npm run test:edge-cases

# Generate static test data files
npm run test:generate-data -- --scenario=all --output=./test/fixtures
```

### Development Benefits

1. **Isolated Testing**: Test backend logic without real ccusage dependencies
2. **Reproducible Scenarios**: Consistent test cases for debugging
3. **Edge Case Coverage**: Simulate hard-to-reproduce real-world scenarios
4. **Performance Validation**: Stress test with multiple concurrent clients
5. **Development Speed**: Quick iteration without manual client setup

---

## Backend Usage Monitoring (Cron Jobs)

### Overview
The backend server also monitors its own Claude usage through scheduled cron jobs, treating itself as a client in the sync calculation.

### Implementation Design

#### Cron Job Service
```javascript
class BackendUsageMonitor {
  constructor(databaseService, clientId) {
    this.db = databaseService;
    this.clientId = clientId;  // Backend's own client ID
    this.lastSignature = null;
  }
  
  async monitorUsage() {
    try {
      // Execute ccusage blocks --json
      const ccusageOutput = await this.executeCcusage();
      
      // Calculate signature for change detection
      const currentSignature = this.calculateSignature(ccusageOutput);
      
      // Only process if changed
      if (currentSignature !== this.lastSignature) {
        await this.processUsageData(ccusageOutput);
        this.lastSignature = currentSignature;
      }
    } catch (error) {
      console.error('Backend usage monitoring failed:', error);
    }
  }
  
  async processUsageData(ccusageData) {
    // Direct database insert (bypass WebSocket)
    // Use same data structure as external clients
    const blocks = ccusageData.blocks || [];
    
    for (const block of blocks) {
      await this.db.upsertUsageBlock({
        blockId: block.id,
        clientId: this.clientId,
        startTime: new Date(block.startTime),
        endTime: new Date(block.endTime),
        actualEndTime: block.actualEndTime ? new Date(block.actualEndTime) : null,
        isActive: block.isActive,
        ccusageFetchedAt: new Date(), // Current time
        totalTokens: block.totalTokens,
        costUsd: block.costUSD,
        tokenCounts: block.tokenCounts,
        rawData: block
      });
    }
    
    console.log(`Backend usage updated: ${blocks.length} blocks processed`);
  }
}
```

#### Cron Job Configuration
```javascript
// In app.js or separate cron service
const cron = require('node-cron');

// Monitor every 30 seconds (configurable)
const monitoringInterval = process.env.BACKEND_USAGE_INTERVAL || '*/30 * * * * *';

cron.schedule(monitoringInterval, async () => {
  await backendUsageMonitor.monitorUsage();
});
```

### Key Differences from External Clients

1. **Direct Database Access**: No WebSocket communication needed
2. **Same Data Structure**: Uses identical ccusage block format
3. **Same Change Detection**: SHA256 hash comparison
4. **Unified Calculation**: Participates in same sync window logic
5. **Self Client ID**: Backend has its own UUID like external clients

### Environment Configuration

```bash
# .env
BACKEND_USAGE_INTERVAL=*/30 * * * * *  # Monitor every 30 seconds
BACKEND_CLIENT_NAME=backend-server     # Friendly name for backend client
DATABASE_URL=postgresql://...          # Database connection
```

### Benefits

1. **Complete Usage Tracking**: Backend's own Claude usage included in calculations
2. **Unified Logic**: Same sync window algorithm for all usage sources  
3. **Direct Efficiency**: No WebSocket overhead for backend data
4. **Consistent Data**: Same change detection and storage mechanism
5. **Centralized Monitoring**: All usage (backend + clients) in one place